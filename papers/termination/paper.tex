
\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{pifont}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{pgf}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{multicol}
\usepackage{appendix}
\usepackage{caption}
\DeclareCaptionType{copyrightbox}
\usepackage{subfig}
\usepackage{tikz}
\usetikzlibrary{arrows, automata, shapes}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\xmark}{\ding{55}}
\newcommand{\todo}[1]{{\bf TODO:} #1}

\lstset{language=c++}



\begin{document}

%\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{POPL '14}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{2014} 

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\title{Synthesising Complex Termination Arguments}

\authorinfo{Cristina David\and Daniel Kroening\and Matt Lewis}
           {Oxford University}
           {firstname.lastname@cs.ox.ac.uk}

\maketitle

\begin{abstract}
Proving program termination is typically done by finding a well-founded \emph{ranking function}
for the program states.
Existing termination provers typically find ranking functions
using either linear algebra or templates.  As such they are often restricted to
finding linear ranking functions over mathematical integers.  This class
of ranking functions is not large enough to prove termination for all terminating
programs, and furthermore a termination argument for a program operating on mathematical integers
does not always lead to a termination argument for the same program operating on
fixed-width machine integers.

We present a reduction from program \emph{termination} to program \emph{synthesis}.
This reduction allows us to generate nonlinear, lexicographic ranking functions that
are correct for fixed-width machine arithmetic and floating-point arithmetic.
We use this reduction to build a semi-decision procedure for the termination
of fixed-width and floating-point arithmetic programs.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}


\keywords
Termination, Program Synthesis, Lexicographic Ranking Functions, Bitvector Ranking Functions,
Floating Point Ranking Functions.

\section{Introduction}

Proving program termination is typically done by finding a well-founded \emph{ranking function}
for the program states. When doing so, the majority of the existing termination provers diverge 
in one important aspect from the execution
of a program on a computer:
bit-vectors and floats 
are treated as mathematical integers and reals, respectively \cite{}.
This approximation gives rise to 
{\em unsound} and {\em incomplete} analyses, which is rather surprising given that bit-vectors and floats are ubiquitous in computer systems. 



For the case of bit-vectors (machine-level integers), their abstraction  to mathematical integers 
ignores the wrap-around behaviour caused by under/over-flows in bit-vector arithmetic, resulting in %, it gives rise to 
%{\em unsound} and {\em incomplete} analyses, which is rather surprising given that bit-vectors are ubiquitous in computer systems. 
incomparable behaviours with respect to termination:
%The differences between the semantics of unbounded mathematical integers and that of machine integers result in 
\begin{itemize}
\item Programs that terminate for integers may \emph{not} terminate for bit-vectors. For illustration, consider the following loop:
\begin{lstlisting}[language=C]
while (x > 0) x -= 2;
\end{lstlisting}
The loop always terminates for unbounded integers as the value of \texttt{x} does eventually become negative, 
whereas, with bit-vector arithmetic, \texttt{x} under-flows before becoming negative and goes back to being positive causing the loop to never terminate.
According to the C11 standard for the C programming language, a signed under- or over-flow yields undefined behaviour.
However, compilers generally treat signed under- and over-flows using the
wrap-around behaviour (see Section~\ref{}). 
\item Similarly, programs that terminate for bit-vectors may \emph{not} terminate for integers. One such situation is illustrated next:  
 \begin{lstlisting}[language=C]
 while(x > 0) x++;
 \end{lstlisting}
This loop is  terminating for bit-vectors since \texttt{x}
will eventually over-flow and become negative. Conversely, the same program is non-terminating using integer
arithmetic since the loop condition stays always true for any initial \texttt{x} at least 1.
\end{itemize}

A scenario similar to the one for bit-vectors happens when floats are abstracted to unbounded reals by termination provers \cite{}.
Consequently, these provers ignore potential rounding errors, under- and over-flows, which are precisely what makes  reasoning about floating point inherently difficult.
This approximation may lead to erroneous diagnosis of a program's terminating behaviour as illustrated next:
\begin{itemize}
\item This loop does not terminate for reals, but does for floats.
\begin{lstlisting}
while (x > 0.0) x *= 0.5;
\end{lstlisting}

\item The following loop terminates for reals, but does not for floats.
\begin{lstlisting}
while (x > 0.0) x -= 1.0;
\end{lstlisting}
\end{itemize}   
\todo{explain the reasons for non-termination with figures.}


Another limitation of the state of the art in the computation of ranking functions is the fact that  most techniques assume \emph{restrictive transition relations} and are only able to compute
\emph{linear ranking functions} \cite{}. To better understand this restriction, we computed the probability of a random terminating program having a linear ranking
function (see Section ?). This probability proved to be very low, indicating that the linearity assumption for the ranking functions is indeed prohibitive.

We propose a general framework that does not assume the existence of linear ranking functions and can uniformly compute
(lexicographic) linear and non-linear ones, 
for programs with both bit-vectors and floats. Our technique can handle programs with non-linear operations, e.g. logical and.
For this purpose, we rephrase the termination problem as a second-order satisfaction problem
(indeed, a program synthesis problem). 
As a direct consequence, our technique is semantic in nature and does not
dependent on the size of the analysed program or its number of variables. 
However, its efficiency does depend on the Kolmogorov
 complexity of the computed ranking functions. We show that the probability of
a ranking function to have a low Kolmogorov complexity is higher than the probability to be linear (see Section~?). 
%We empirically observe that most programs have
%ranking functions with low Kolmogorov complexity (see Section ?). 

%Church was BIG into program synthesis~\cite{church-synth}, so you know it's good stuff.
%Something, something, Curry-Howard Isomorphism, something, something, programs-as-proofs.

The main contributions of our paper are highlighted below:
\begin{itemize}
\item We designed a technique for computing ranking functions that correctly accounts for the wrap-around behavior caused by under- and overflows in bit-vector and floating point arithmetic. To the best of our knowledge, this is the first approach able to compute ranking functions for programs handling floats. Our technique is not restricted to finding linear ranking functions, but can also compute (lexicographic) non-linear  ones. We justified the need for such a non restrictive procedure by computing the probability ... .
\item  We rephrased the termination problem as a second-order satisfaction problem and made 
use of results in genetic programming to efficiently solve it. We have also investigated the effects of genetic operators on the search space for ranking functions and computed theoretical 
bounds on the convergence time ...
\item We implemented our technique and tried it on a selection of programs handling both bit-vectors and floats.  
\end{itemize}

This paper is organised as follows:

\section{Related Work}
Error 404.


\section{Motivational Examples}
A non-linear program with a linear ranking function (+ program with non-linear operations):
\begin{lstlisting}
while (x > 0)
 x = (x - 1) & x;
\end{lstlisting}

A linear program with a non-linear ranking function:
\begin{lstlisting}
while (x != 0)
 x = -x / 2;
\end{lstlisting}

\section{Preliminaries}
\subsection{Termination and Ranking Functions}
A transition system with state space $X$ and transition relation $T \subseteq X \times X$
is said to be \emph{unconditionally terminating} if there is no infinite sequence
$x_1, x_2, \ldots$ with $\forall i . T(x_i, x_{i+1})$.  We can prove that $T$ is
unconditionally terminating by finding an injective function $R: X \to Y$ where
$Y$ is well-founded and $R$ is monotonically decreasing with respect $T$.  That is
to say:
$$\forall x, x' . T(x, x') \Rightarrow R(x) < R(x')$$

A special case of a ranking function is a \emph{linear ranking function}.  This
class of functions is exactly what you'd expect: a linear function that satisfies
the criteria for a ranking function.  We recall that a linear function $f: X \to Y$,
with $\dim(X) = n$ and $\dim(Y) = m$
is one that can be expressed as an $n \times m$ matrix $M$:
$$f(\vec{x}) = M\vec{x}$$

In the case that $\dim(Y) = 1$, this reduces to an inner product:
$$f(\vec{x}) = \vec{\lambda} \cdotp \vec{x} + c$$

If $Y = Z^m$, we say that the ranking function is \emph{lexicographic},
and require that the total order imposed on $Y$ is the lexicographic ordering
induced on tuples of $Z$'s.  We note that some termination arguments
require lexicographic ranking functions, or equivalently, ranking functions
whose co-domain is the ordinals, rather than just $\mathbb{N}$.

\subsection{Machine Arithmetic and Bitvectors}
Computers tend to have fixed width integers.  For a machine with $k$-bit words,
all arithmetic is done modulo $2^k$.  This means that a program's termination
behaviour can depend strongly on whether it is interpreted as operating over
mathematical integers, or over fixed-width machine words.  We can however
observe that if no arithmetic operation \emph{overflows} (i.e. does not result
in a value greater than $2^k$), fixed-width and integer arithmetic coincide.

\section{Formalism}
In this section, we fix a model of computation, describe its semantics and
define the syntax of a language we will work over.

\subsection{Syntax and Semantics}

\begin{itemize}
 \item Our transition relation is $T(x, x') \subseteq X \times X$.
 \item Our loop condition is $L(x) \subseteq X$.
 \item Our ranking function is $R(x) : X \to Y$.
 \item Our state space has size $\| X \| = M = 2^k$.
 \item Our ranking co-domain has size $\| Y \| = N = 2^j$.
 \item The number of looping states is $\| L \| = l$.
 \item Our transition relation is deterministic and parititioned into chains of length $c_i$, with $l = \sum c_i$.
\end{itemize}

\section{Combinatorics of Termination}

\begin{itemize}
 \item There are a TON of programs (way more than you'd expect).
 \item There are a TON of terminating programs, and for our model of computation we can count
  how many (the Chaitin constant).
 \item There are a TON of ranking functions (way more than you'd expect, but not many as a
  fraction of programs).
 \item There are not many linear functions.
 \item Most terminating programs don't admit linear ranking functions.
 \item The Curry-Howard isomorphism
 \item Kolmogorov complexity is relevant for understanding termination proofs.
\end{itemize}


\begin{theorem}
 A random function $f : X \to Y$ is a ranking function for $(T, L)$ with probability

 $$N^{-l} \times \prod {{N-1} \choose c_i}$$
\end{theorem}

\begin{proof}
 Combinatorics.
\end{proof}


\begin{corollary}
 This number is really small (e.g. $10^{-193}$ for a 64-bit program with 1 variable and 10 looping states.
 Randomly sampling functions \& hoping they're ranking functions is not going to work.
\end{corollary}


\begin{conjecture}
 The probability that a random program $(T, L)$ is terminating (the Chaitin constant)
 is $0.7$.
\end{conjecture}

\begin{conjecture}
 The probability that a random program $(T, L)$ admits a linear ranking function is
 $0.1$.
\end{conjecture}

\begin{conjecture}
 The probability that a random, terminating program $(T, L)$ admits a linear ranking function
 is $0.2$.
\end{conjecture}


\begin{corollary}
 Most terminating programs do not have linear ranking functions.
\end{corollary}


\section{Termination as Second-Order Satisfaction}
We can specify the existence of a ranking function, and therefore the termination
of a program, using a second order formula:

\begin{definition}[Second-order Termination Formula]
\begin{align*}
 \exists R . \forall x, x' . & R(x) > 0 ~ \wedge \\
                             & T(x, x') \rightarrow R(x) > R(x')
\end{align*}
\end{definition}

\section{Second-Order Satisfaction as Program Synthesis}
The program synthesis problem can be described as finding a satisfying assigment to the
synthesis formula:

\begin{definition}[Synthesis Formula]
 The synthesis formula for a specification $\sigma: X \to Y$ is:
 
 $$\exists P \cdotp \forall x \cdotp \sigma(x, P(x))$$
 \end{definition}

Since this formula involves quantification over functions $X \to Y$,
this is a second-order formula -- indeed, if $X = Y = \mathbb{N}$,
the formula describes a set at level $\Sigma_1^1$ of the analytical
hierarchy.  As such, determining the satisfiability of the synthesis
formula over a given logic is strictly harder than solving the
halting problem over the same logic.

\subsection{Generalised Synthesis}
Sometimes we want to synthesise several programs at once, as well as some
ground terms $\vec{x}$.  Also, we might want a more complex specification
than just a relation over $X$ and $Y$.

\begin{definition}[Generalised Synthesis Formula]
 $$\exists P, \vec{x} \cdotp \forall \vec{y} \cdotp \sigma(x, P, y) $$
\end{definition}

\subsection{Reducing Termination to Synthesis}
For a transition system $T$, we can build a specification $\sigma$ to find a conditional ranking function for
$T$ with initial states I:

\begin{eqnarray}
 \sigma(V: X \to \mathbb{B}, R: X \to \mathbb{N}, x, x') = & I(x) \rightarrow V(x) \wedge \\
 & V(x) \wedge T(x, x') \rightarrow V(x') \wedge R(x) < R(x') 
\end{eqnarray}

Here we have synthesised a ranking function $R$ into $\mathbb{N}$ (which is well-founded),
as well as an inductive invariant $V$ that guarantees termination of $T$.

To synthesise an n-place lexicographic ranking function, we just ask for a ranking function
$R: X \to \mathbb{N}^n$.

We recall the definition of the Kolmogorov-complexity of a function $f$:

\begin{definition}[Kolmogorov complexity]
 The Kolmogorov complexity $K(f)$ is the length of the shortest program that
 computes $f$.
\end{definition}

We are primarily interested in studying low-Kolmogorov-complexity (LKC)
functions.

\begin{theorem}
 Linear functions are LKC.
\end{theorem}

\begin{proof}
 The program to compute a linear function $f: X \to Y$ is of size linear in
 $\dim(X) \times \dim(Y)$.
\end{proof}


\begin{conjecture}
 Most LKC functions are non-linear.
\end{conjecture}

\begin{corollary}
 LKC is a weaker assumption than linearity.
\end{corollary}


\begin{theorem}
 LKC programs do not always have LKC ranking functions.
\end{theorem}

\begin{proof}
 This would solve the halting problem, Goldbach conjecture, Collatz conjecture.
\end{proof}

\begin{conjecture}
 High-Kolmogorov-complexity (HKC) programs often have LKC ranking functions.
\end{conjecture}

\begin{theorem}
 \textsc{Headshot} is biased towards finding ranking functions with
 low-Kolmogorov-complexity (LKC).
\end{theorem}

\begin{proof}
 Trivial.
\end{proof}

\begin{conjecture}
 Most LKC programs compute non-linear functions, but linear functions are LKC.
 So LKC is a weaker assumption than linearity.
\end{conjecture}

\begin{corollary}
 \textsc{Headshot} can often prove termination where linear methods cannot.
\end{corollary}



\section{Solving the Synthesis Formula}
\input{kalashnikov}

\section{Genetic Programming and Incremental Evolution}

We begin by observing that the asymptotic complexity of all of our synthesis
backends are equal, assuming $P \neq NP$.  This complexity is:

$$O(2^{K(f)}$$

Where $K(f)$ is the Kolmogorov complexity of $f$, which is $O(\log Y^X) = O(X)$
so the complexity is doubly exponential in the width of $X$.

\begin{definition}
 A \emph{fitness landscape} is the space of all programs along with their fitness.
\end{definition}

\begin{theorem}
 Fitness landscapes form a lattice.  Adding test vectors corresponds to abstraction refinement on this
 lattice, which is why incremental GP works well.
\end{theorem}

\begin{proof}
 Trivial.
\end{proof}


\begin{conjecture}
 A single fitness landscape isn't really very smooth (e.g. small changes in program representation
 don't correspond to small changes in fitness), so GP probably shouldn't work very well.
 
 But it does.
\end{conjecture}



\section{Experiments}

We implemented our fully automatic program synthesis procedure in the \textsc{Kalashnikov} tool.


\begin{figure*}
\centering
\begin{tabular}{|l|r|r||r|r|r|r|}
\hline
    & LOC & \shortstack{Rank function \\ size} & \textsc{T2} & \textsc{ARMC} & \textsc{Headshot} & \textsc{Headshot-Linear} \\
    \hline
    \hline
 P1 & 10 & 3 & 100s & 70s & 0.1s & \bf{0.01s} \\
 P2 & 10 & 3 & 100s & 70s & 0.1s & \bf{0.01s} \\
 P3 & 10 & 3 & 100s & 70s & 0.1s & \bf{0.01s} \\
 \hline
\end{tabular}
\caption{Termination for linear programs with disjunctive, linear ranking functions\label{fig:linear}}
\end{figure*}

\begin{figure*}
\centering
\begin{tabular}{|l|r|c|c|r|r|r|}
\hline
    & LOC & \shortstack{Linear \\ program?} & \shortstack{Linear ranking \\ function?}  & Dimension & \shortstack{Ranking \\ program size} & Time (s)\\
    \hline
    \hline
 P1 & 10 & \xmark & \xmark & 3 & 1 & 0.01 \\
 P2 & 10 & \xmark & \xmark & 3 & 1 & 0.01 \\
 P3 & 10 & \xmark & \xmark & 3 & 1 & 0.01 \\
 \hline
\end{tabular}

\caption{\textsc{Headshot} termination for nonlinear programs with nonlinear ranking functions\label{fig:nonlinear}}
 \end{figure*}


\bibliographystyle{abbrvnat}
\bibliography{synth}{}

\end{document}
