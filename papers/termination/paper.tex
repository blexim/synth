
\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{pifont}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{pgf}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{multicol}
\usepackage{appendix}
\usepackage{caption}
\DeclareCaptionType{copyrightbox}
\usepackage{subfig}
\usepackage{multirow}
\usepackage{tikz}
\usetikzlibrary{arrows, automata, shapes}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\newcommand{\xmark}{\ding{55}}
\newcommand{\todo}[1]{{\bf TODO:} #1}

\lstset{language=c++}



\begin{document}

%\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{POPL '14}{Month d--d, 20yy, City, ST, Country} 
\copyrightyear{2014} 

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\title{Synthesising Complex Termination Arguments}

\authorinfo{Cristina David\and Daniel Kroening\and Matt Lewis}
           {Oxford University}
           {firstname.lastname@cs.ox.ac.uk}

\maketitle

\begin{abstract}
Proving program termination is typically done by finding a well-founded \emph{ranking function}
for the program states.
Existing termination provers typically find ranking functions
using either linear algebra or templates.  As such they are often restricted to
finding linear ranking functions over mathematical integers.  This class
of ranking functions is not large enough to prove termination for all terminating
programs, and furthermore a termination argument for a program operating on mathematical integers
does not always lead to a termination argument for the same program operating on
fixed-width machine integers.

We present a reduction from program \emph{termination} to program \emph{synthesis}.
This reduction allows us to generate nonlinear, lexicographic ranking functions that
are correct for fixed-width machine arithmetic and floating-point arithmetic.
We use this reduction to build a semi-decision procedure for the termination
of fixed-width and floating-point arithmetic programs.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}


\keywords
Termination, Program Synthesis, Lexicographic Ranking Functions, Bitvector Ranking Functions,
Floating Point Ranking Functions.

\section{Introduction}

Proving program termination is typically done by finding a \emph{ranking function}
for the program states, i.e. a map from the program's state space to a well-ordered set.
As this definition of a ranking function is very general, research is often limited to some
convenient and tractable form of ranking functions, most frequently \emph{linear ranking functions} (see Section~\ref{sec:ranking.functions}). 
In doing so, an analysis ensures that such a ranking function will be found if one  exists, 
while failing to prove termination for terminating programs whose ranking functions fall short of the considered restriction. 

Moreover, the majority of the existing termination provers diverge 
in one important aspect from the execution of a program on a computer:
bit-vectors and floats 
are treated as mathematical integers and reals, respectively.
This approximation gives rise to 
{\em unsound} and {\em incomplete} analyses, which is rather surprising given that bit-vectors and floats are ubiquitous in computer systems. 

Figure~\ref{fig:handletable} presents a summary of existing termination analyses with indeed
most of the work concentrated on finding \emph{linear ranking functions for linear programs over integers}.
Next, we will consider in more detail the assumptions made by such techniques and their implications.\\

\noindent {\bf Bit-vectors (machine-level integers) vs. mathematical integers.} The abstraction of bit-vectors to mathematical integers 
ignores the wrap-around behaviour caused by under/over-flows in bit-vector arithmetic, resulting in %, it gives rise to 
%{\em unsound} and {\em incomplete} analyses, which is rather surprising given that bit-vectors are ubiquitous in computer systems. 
incomparable behaviours with respect to termination:
%The differences between the semantics of unbounded mathematical integers and that of machine integers result in 
\begin{itemize}
\item Programs that terminate for integers may \emph{not} terminate for bit-vectors. For illustration, consider the following loop:
\begin{lstlisting}[language=C]
while (x > 0) x -= 2;
\end{lstlisting}
The loop always terminates for unbounded integers as the value of \texttt{x} does eventually become negative, 
whereas, with bit-vector arithmetic, \texttt{x} under-flows before becoming negative and goes back to being positive causing the loop to never terminate.
According to the C11 standard for the C programming language, a signed under- or over-flow yields undefined behaviour.
However, compilers generally treat signed under- and over-flows using the
wrap-around behaviour (see Section~\ref{sec:machine.arith}). 
\item Similarly, programs that terminate for bit-vectors may \emph{not} terminate for integers. One such situation is illustrated next:  
 \begin{lstlisting}[language=C]
 while(x > 0) x++;
 \end{lstlisting}
This loop is  terminating for bit-vectors since \texttt{x}
will eventually over-flow and become negative. Conversely, the same program is non-terminating using integer
arithmetic since the loop condition stays always true for any initial \texttt{x} at least 1.
\end{itemize}

\noindent {\bf Floats vs. reals.} A scenario similar to the one for bit-vectors happens if floats were to be abstracted to unbounded reals by termination provers \cite{}. 
Consequently, these provers ignore potential rounding errors, under- and over-flows, which are precisely what makes  reasoning about floating point inherently difficult.
This approximation may lead to erroneous diagnosis of a program's terminating behaviour as illustrated next:
\begin{itemize}
\item This loop does not terminate for reals, but does for floats.
\begin{lstlisting}
while (x > 0.0) x *= 0.5;
\end{lstlisting}

\item The following loop terminates for reals, but does not for floats.
\begin{lstlisting}
while (x > 0.0) x -= 1.0;
\end{lstlisting}
\end{itemize}   
\todo{explain the reasons for non-termination with figures.}\\


\noindent {\bf Linear programs and linear ranking functions.} As visible in Figure~\ref{fig:handletable}, 
most termination techniques assume \emph{restrictive transition relations}, e.g. linear programs,  and are only able to compute
\emph{linear ranking functions} \cite{}. To better understand this restriction, we computed the probability of a random terminating program having a linear ranking
function (see Section ?). This probability proved to be very low, indicating that the linearity assumption for the ranking functions is indeed prohibitive.


We propose a general framework that does not assume the existence of linear ranking functions and can uniformly compute
\emph{lexicographic/non-lexicographic} \emph{linear/non-linear} 
ranking functions supported by inductive \emph{linear/non-linear} invariants for loops with 
\emph{linear/non-linear} guards and transitions over bit-vectors and floats.
Our technique is {\emph complete} and can handle programs with non-linear operations, e.g. logical and.
For this purpose, we rephrase the termination problem as a second-order satisfaction problem
(indeed, a program synthesis problem). 
As a direct consequence, our technique is semantic in nature and does not
dependent on the size of the analysed program or its number of variables. 
However, its efficiency does depend on the Kolmogorov
 complexity of the computed ranking functions. We show that the probability of
a ranking function to have a low Kolmogorov complexity is higher than the probability to be linear (see Section~?).


\begin{figure*}
\centering
 \begin{tabular}{|ll||c|c|c|c|c|c|c|c|}
 \hline
  & & \multicolumn{8}{c|}{Program} \\
  & & \multicolumn{2}{c|}{Integers} & \multicolumn{2}{c|}{Reals} & \multicolumn{2}{c|}{Bit-vectors} & \multicolumn{2}{c|}{Floats} \\
  & & L & NL & L & NL & L & NL & L & NL \\
  \hline
  \hline
  \multirow{4}{*}{Ranking} & Linear lexicographic &  \cite{DBLP:conf/cav/BradleyMS05} && & &\checkmark&\checkmark&\checkmark&\checkmark\\
   & Linear non-lexicographic & \cite{DBLP:conf/pldi/CookPR06,DBLP:conf/cav/LeeWY12,DBLP:conf/popl/Ben-AmramG13} & & && \checkmark~ \cite{DBLP:conf/tacas/CookKRW10} &\checkmark~ \cite{DBLP:conf/tacas/CookKRW10}&\checkmark&\checkmark\\
   & Non-linear lexicographic &  &  & &&\checkmark&\checkmark&\checkmark&\checkmark\\
   & Non-linear non-lexicographic &  &  & &&\checkmark&\checkmark&\checkmark&\checkmark\\
   \hline
 \end{tabular}

 \caption{Legend: \checkmark = we can handle\label{fig:handletable}}
\end{figure*}


%We empirically observe that most programs have
%ranking functions with low Kolmogorov complexity (see Section ?). 

%Church was BIG into program synthesis~\cite{church-synth}, so you know it's good stuff.
%Something, something, Curry-Howard Isomorphism, something, something, programs-as-proofs.

 The main contributions of our work can be summarised as follows:
\begin{itemize}
\item We designed a technique for computing ranking functions that correctly accounts for the wrap-around behavior caused by under- and overflows in bit-vector and floating point arithmetic. To the best of our knowledge, this is the first approach able to compute ranking functions for programs handling floats. Our technique is not restricted to finding linear ranking functions, but can also compute (lexicographic) non-linear  ones. We justified the need for such a non restrictive procedure by computing the probability ... .
\item  We rephrased the termination problem as a second-order satisfaction problem and made 
use of results in genetic programming to efficiently solve it. We have also investigated the effects of genetic operators on the search space for ranking functions and computed theoretical 
bounds on the convergence time ...
\item We present a formulation that allows us to prove termination without using a fancy safety prover (because
we don't do a DWF proof).  In particular,
we only need a bounded model checker that performs a single unwinding of a loop.
\item Our technique is able to uniformly handle conditionally-terminating loops, as well as programs with
multiple loops.
\item We implemented our technique and tried it on a selection of programs handling both bit-vectors and floats.
\end{itemize}

%. only non-strict inequalities can be transformed using Farkas’ Lemma
%--Our approach to termination analysis has two distinct features over previous works
%-- a lexicographic ranking function imposes a lexicographic ordering on among the ranking function components.

Other points to touch in the introduction:
\begin{itemize}
\item disjunctive well-foundedness: By phrasing the termination problem as a single rank function synthesis problem, we observe that
we can make the termination problem as hard as finding ranking functions, rather than as hard as
solving a difficult ``double reachability'' problem (cf. Terminator).
\item The lexicographic ordering does not influence the size of the search space. Thus, finding potentially lexicographic termination arguments is not more difficult than finding non-lexicographic ones.   
\item Compared to the previous approaches that mostly aim to find a particular form of ranking functions, our technique does not commit to any particular one. We will find the one that has the lowest Kolmogorov complexity.
\item Many loops do not terminate for all starting states, but are contained in programs that guarantee the loop will
terminate.  Traditional termination provers have difficulty reasoning about such conditionally-terminating loops.
We are able to handle such loops by computing \emph{termination invariants}.  This mechanism also allows us to
prove that programs with multiple loops terminate, even if the termination of some loop depends on the states
reachable after leaving a previous loop.
\item Linearity vs. LKC.
\end{itemize}

This paper is organised as follows:

\section{Related Work}
\subsection{Termination analysis}
Given the multitude of works on termination, we have tried to summarise them in Figure~\ref{fig:handletable}. 

The existing work on termination is primarily divided into structural (syntactic) vs. semantic approaches.  
For example, terminationg of term rewriting systems is largely structural, whereas DWF analysis (cf. Terminator) is more semantic. While it deals
with transition relations, it also uses some amount of syntax in that it identifies loops \& looping paths.

A program is lasso-shaped if it is composed by a stem followed by a single loop without branching, i.e. there is only one path. 
Consequently, the termination argument can be very simple. There are numerous techniques specialised in
proving termination of lasso-shaped programs efficiently \cite{DBLP:conf/popl/Ben-AmramG13,DBLP:conf/cav/BradleyMS05,DBLP:conf/atva/HeizmannHLP13,DBLP:conf/vmcai/P04}. 

Lee et al. make use of transition predicate abstraction, algorithmic learning, and decision procedures to compute transition
invariants as proofs for the termination of linear programs \cite{DBLP:conf/cav/LeeWY12}.

There is very limited work on generating ranking functions for relations over machine integers.
Cook et al. present a method based on a reduction to Presburger
arithmetic, and a template-matching approach for predefined classes of
ranking functions based on reduction to SAT- and QBF-solving \cite{DBLP:conf/tacas/CookKRW10}.

Leike and Heizmann present a new method for the constraint-based synthesis
of termination arguments for linear loop programs based on
linear ranking templates \cite{DBLP:conf/tacas/LeikeH14}.

Learning: \cite{DBLP:journals/corr/HeizmannHP14}

Polynomial programs: \cite{DBLP:conf/vmcai/BradleyMS05}

Linear ranking functions supported by inductive linear invariants for loops with linear guards and transitions: \cite{DBLP:conf/cav/BradleyMS05}. 

\subsection{Disjunctive well-foundedness}
Cook et al. are closer to a semantic approach by viewing the termination proving task as a binary reachability analysis \cite{DBLP:conf/pldi/CookPR06}.
%Terminator incrementally constructs the union of ranking relations.
%Given that the this union is not well-founded (it is only disjunctively well-founded), 
%Terminator must prove that the binary reachability relation of the program (the transitive closure of the transition relation restricted to reachable states) 
%is contained in the union of ranking relations.
%Thus, this approach requires an evolved binary reachability, and, implicitly, the assistance of a safety prover.
In particular, their technique incrementally constructs the union of ranking relations.
Given that the this union is not well-founded (it is only disjunctively well-founded),
they must show that, for every sequence, one of the ranking functions decreases
between the pre- and post-state. %In other words: it 
%must find all pairs of states reachable from the program's initial state 
%such that one is reachable from the other and it must show 
%that the value of one of the ranking functions decreases from s1 to s2. 
Consequently, most of the analysis time is spent in reachability analysis that is to check if the current
transition invariant reached a fixed point.

As we want to avoid the requirements of a binary reachability analysis, our termination argument is not a set
of ranking functions, but a single ranking function, which we prove is enough for proving the termination of any termination program. 
With a single ranking function we only need to show that the rank decreases from the
pre- to post-state after executing each single transition step.
The checking process is therefore easy. For the construction of the ranking function, we 
formulate the problem as a second order satisfaction formula and we solve it via program synthesis.


Because most state-of-the-art termination procedures use disjunctive well foundedness arguments, they require the use of
complex safety provers that are able to reason about unbounded unfoldings of a transition relation.  In contrast to this,
we are able to build monolithic termination arguments that only need ``local'' reasoning -- our ranking functions
can be proved sufficient by considering just a single unfolding of a loop.



%-- Usually the termination argument for the program LOOPS
%on Figure 1 is based on a lexicographic combination
%of well-founded orderings.


%-- the union T of ranking relations, however, is in general not well-founded
%(it is only disjunctively well-founded in the terminology of [23]). This is
%why it would not be sufficient to show the inclusion R \subseteq  T, and why we must in stead prove R_I^+ \subseteq T.

\subsection{Synthesis}

%% ---
%% constructs and checks the termination argument

%% T ERMINATOR’s most distinguishing aspect, with respect to pre-
%% vious methods and tools for proving program termination, is how it
%% shifts the balance between the two tasks of constructing and respec-
%% tively checking the termination argument. The classical method is
%% to construct an expression defining the rank of a state and then to
%% check that its value decreases in every transition from a reachable
%% state to a next one. The construction of the ranking function is the
%% hard part and forms a task that needs to be applied to the whole
%% program. The checking part is relatively easy. In our method, the
%% task of constructing ranking functions is the relatively easy part;
%% they are constructed on demand based on the examination of only
%% a few selected paths through the program.

%% Previously, it was not known whether binary reachability analysis could be made
%% practical. The challenge raised by our approach was to show that
%% this is indeed the case.

%% ----------
%% Efficient synthesis of ranking functions for machine-level bit-vectors, how-
%% ever, has remained an open problem.
%% ---------

\section{Motivational Examples} 
We next discus some intricate examples that prove challenging for existent termination analysis.
%a few examples that illustrate the difficulties in termination checking for low-level code. In particular, they denote situations that arise 
%frequently in practise and are not properly handled by existing techniques. 

%We now present a few examples that justify 

\subsection{Program linearity vs. the linearity of its ranking function.}
The first examples we consider illustrate the lack of a direct correlation between the linearity of a program and that of its termination arguments.
As such, Figure~\ref{} denotes a program with non-linear operations. Given that  many of the existing techniques commit to linear programs, they cannot handle this situation, 
although a linear ranking function does exist (see Figure~\ref{fig:handletable}). 

In order to find a ranking function for this example, it is necessary to take into account
the semantics of the bit-wise AND operator, which is not easily done when working with mathematical integers \cite{}.
Our technique finds that a possible ranking function is the linear function
$R(x) = x$, whose value decreases with
every iteration, but it can not decrease indefinitely as it is bounded from below.

Conversely, Figure~\ref{} shows a linear program with a non-linear ranking function.

Figure~\ref{} is a linear program taken from \cite{DBLP:conf/tacas/CookSZ13}, where it is shown to not admit (without prior manipulation) a lexicographic linear function, but only a disjunctively well-founded one, 
which requires an expensive binary reachability analysis.
However, by using our technique we can find a non-linear lexicographic ranking functions.
A lexicographic non-linear ranking functions consists of lexicographically ordered components
of non-linear functions. As with linear lexicographic ranking functions, a state is mapped to a tuple of values such that the
loop transition leads to a decrease with respect to the lexicographic
ordering for this tuple. Therefore no function may increase unless a function of
a lower index decreases. Additionally, at every step, there must be at least one
function that decreases.

\begin{lstlisting}
while (x > 0)
 x = (x - 1) & x;
\end{lstlisting}

\begin{lstlisting}
while (x != 0)
 x = -x / 2;
\end{lstlisting}

\begin{lstlisting}
  while (x != 0) {
    if (x > 0)
      x--;
    else
      x++;
  }
\end{lstlisting}

\subsection{Differences in the termination behaviour for integers and bit-vectors.}
We have collected a number of motivational examples from other termination papers that treat bit-vectors as mathematical integers \cite{DBLP:conf/tacas/LeikeH14,DBLP:conf/tacas/CookSZ13}. 
We show that the termination arguments computed by such techniques do not directly apply when considering the bit-vector semantics.
%these programs actually exhibit different terminating behaviours for bit-vectors and integer  

\begin{lstlisting}
  while (x != m) {
    if (x > m)
      x = 0;
    else
      x++;
  }
\end{lstlisting}

\begin{lstlisting}
while ( q >= 0 ) {
  q = q - y;
  y = y + 1;
}
\end{lstlisting}

Every execution of the program in Figure~\ref{} can be partitioned into two phases: in the first phase $y$ increases
until it is positive (in this phase $q$ may increase), whereas in the second $q$ decreases until the loop condition is violated. 
\cite{DBLP:conf/tacas/LeikeH14} proposes using a linear ranking template in order to obtain a ranking function that proceeds
through a fixed number of phases in the program execution. Each phase is ranked by a linear function, and ends when this function becomes non-positive.
However, when considering the bit-vector semantics, this program does not terminate.

\subsection{Differences in the termination behaviour for reals and floats.}
\begin{lstlisting}
while (x > 0.0) x -= 1.0;
\end{lstlisting}

\begin{lstlisting}
while (x > 0.0) x *= 0.5;
\end{lstlisting}


\subsection{Multi-phase ranking functions}
%\subsection{Lexicographic ranking function with strict inequalities.}
%Approaches based on Farkas’ Lemma can only handle non-strict inequalities \cite{DBLP:conf/cav/BradleyMS05,DBLP:conf/vmcai/P04}.
The program in Figure~\ref{} is taken from SVCOMP'15  \footnote{http://sv-comp.sosy-lab.org/2015/index.php} termination benchmarks.
In the terminology of \cite{DBLP:conf/tacas/LeikeH14}, this program admits a multi-phase ranking function, i.e. ..,  with a dedicated technique for computing it. However, in our setting 
this type of programs do not need a special treatment, as we can find a non-linear ranking function for it as follows:
\begin{verbatim}
R(x, y, z) = (x < y, z)
\end{verbatim}

%% t3 is "If x >= y, then x' >= y'" where x' is the next value of x.  This can be interpreted as "if the 'else' branch of the if is taken once, it is taken forever", which can be seen by induction.
%% t2 is z -- this is probably the sickest part.  In the 'else' branch, z just decreases.  In the 'then' branch, we get:

%% y > x
%% y' = z
%% x' = nondet()
%% z' = x' - 1

%% Let's consider 2 cases:

%% case z' >= z, then:
%%   x' - 1 >= z, so
%%   x' - 1 >= y', so
%%   x' > y',
%%   so (x < y) has decreased, i.e. we will reamain in the 'else' branch forever and
%% case z' < z, then:
%%   z has decreased.



\begin{lstlisting}
int main(void) {
  int x, y, z;

  while (x > 0 && y > 0 && z > 0) {
    if (y > x) {
      y = z;
      x = nondet();
      z = x - 1;
    } else {
      z = z - 1;
      x = nondet();
      y = x - 1;
    }
  }
}
\end{lstlisting}



\section{Preliminaries}
\subsection{Termination and Ranking Functions} \label{sec:ranking.functions}
\todo{linear program}

A transition system with state space $X$ and transition relation $T \subseteq X \times X$
is said to be \emph{unconditionally terminating} if there is no infinite sequence
$x_1, x_2, \ldots$ with $\forall i . T(x_i, x_{i+1})$.  We can prove that $T$ is
unconditionally terminating by finding an injective function $R: X \to Y$ where
$Y$ is well-founded and $R$ is monotonically decreasing with respect $T$.  That is
to say:
$$\forall x, x' . T(x, x') \Rightarrow R(x) < R(x')$$

A special case of a ranking function is a \emph{linear ranking function}.  This
class of functions is exactly what you'd expect: a linear function that satisfies
the criteria for a ranking function.  We recall that a linear function $f: X \to Y$,
with $\dim(X) = n$ and $\dim(Y) = m$
is one that can be expressed as an $n \times m$ matrix $M$:
$$f(\vec{x}) = M\vec{x}$$

In the case that $\dim(Y) = 1$, this reduces to an inner product:
$$f(\vec{x}) = \vec{\lambda} \cdotp \vec{x} + c$$

If $Y = Z^m$, we say that the ranking function is \emph{lexicographic},
and require that the total order imposed on $Y$ is the lexicographic ordering
induced on tuples of $Z$'s.  We note that some termination arguments
require lexicographic ranking functions, or equivalently, ranking functions
whose co-domain is the ordinals, rather than just $\mathbb{N}$.

\subsection{Disjunctive Well-Foundedness}
Terminator uses disjunctive well foundedness arguments, which can be found
piece by piece, but require reasoning about the transitive closure of a transition
relation.  Because we build a monolithic well foundedness argument, we
do not need to reason about the full transitive closure, and can instead do our
reasoning over a single step of the transition relation.  This means that we
can get away with very simple model checking methods, rather than requiring
a full-blown safety prover.

\subsection{Machine Arithmetic and Bitvectors} \label{sec:machine.arith} 
Computers tend to have fixed width integers.  For a machine with $k$-bit words,
all arithmetic is done modulo $2^k$.  This means that a program's termination
behaviour can depend strongly on whether it is interpreted as operating over
mathematical integers, or over fixed-width machine words.  We can however
observe that if no arithmetic operation \emph{overflows} (i.e. does not result
in a value greater than $2^k$), fixed-width and integer arithmetic coincide.

\section{Combinatorics of Finite Termination}
In this section, we fix a model of computation, describe its semantics and
define the syntax of a language we will work over.

\subsection{Syntax and Semantics}

\begin{itemize}
 \item Our transition relation is $T(x, x') \subseteq X \times X$.
 \item Our loop condition is $L(x) \subseteq X$.
 \item Our ranking function is $R(x) : X \to Y$.
 \item Our state space has size $\| X \| = M = 2^k$.
 \item Our ranking co-domain has size $\| Y \| = N = 2^j$.
 \item The number of looping states is $\| L \| = l$.
 \item Our transition relation is deterministic and parititioned into chains of length $c_i$, with $l = \sum c_i$.
\end{itemize}

\subsection{Counting Programs}
\begin{itemize}
 \item There are a TON of programs (way more than you'd expect).
 \item There are a TON of terminating programs, and for our model of computation we can count
  how many (the Chaitin constant).
 \item There are a TON of ranking functions (way more than you'd expect, but not many as a
  fraction of programs).
 \item There are not many linear functions.
 \item Most terminating programs don't admit linear ranking functions.
 \item The Curry-Howard isomorphism
 \item Kolmogorov complexity is relevant for understanding termination proofs.
\end{itemize}


\begin{theorem}
 A random function $f : X \to Y$ is a ranking function for $(T, L)$ with probability

 $$N^{-l} \times \prod {{N-1} \choose c_i}$$
\end{theorem}

\begin{proof}
 Combinatorics.
\end{proof}


\begin{corollary}
 This number is really small (e.g. $10^{-193}$ for a 64-bit program with 1 variable and 10 looping states.
 Randomly sampling functions \& hoping they're ranking functions is not going to work.
\end{corollary}


\begin{conjecture}
 The probability that a random program $(T, L)$ is terminating (the Chaitin constant)
 is $0.7$.
\end{conjecture}

\begin{conjecture}
 The probability that a random program $(T, L)$ admits a linear ranking function is
 $0.1$.
\end{conjecture}

\begin{conjecture}
 The probability that a random, terminating program $(T, L)$ admits a linear ranking function
 is $0.2$.
\end{conjecture}


\begin{corollary}
 Most terminating programs do not have linear ranking functions.
\end{corollary}


\section{Termination as Second-Order Satisfaction}
We can specify the existence of a ranking function, and therefore the termination
of a program, using a second order formula:

\begin{figure*}
\begin{definition}[Second-order Termination Formula]
\begin{align*}
 \exists R . \forall x, x' . & R(x) > 0 ~ \wedge \\
                             & T(x, x') \rightarrow R(x) > R(x')
\end{align*}
\end{definition}

\begin{definition}[Conditional Termination Formula]
 \begin{align*}
  \exists R, I . \forall x, x' . & P(x) \rightarrow I(x) ~ \wedge \\
                                 & c(x) \wedge I(x) \wedge T(x, x') \rightarrow I(x') \wedge R(x) > 0 \wedge R(x) > R(x')
 \end{align*}
\end{definition}

\begin{definition}[Multiple Loops Termination Formula]
 \begin{align*}
  \exists R, I_1, I_2 . \forall x, x' . & P(x) \rightarrow I_1(x) ~ \wedge \\
                                        & I_1(x) \wedge L_1(x, x') \rightarrow I_1(x') ~ \wedge \\
                                        & I_1(x) \wedge \lnot c_1(x) \rightarrow I_2(x) ~ \wedge \\
                                        & c(x) \wedge I_2(x) \wedge L_2(x, x') \rightarrow I_2(x') \wedge R(x) > 0 \wedge R(x) > R(x')
 \end{align*}
\end{definition}
\end{figure*}

Our method for ranking function synthesis can be stated as follows:
discuss what spec is used (non-lexicographic vs lexicographic) + the completeness claims.
Any termination guarantees?  

\section{Second-Order Satisfaction as Program Synthesis}
The program synthesis problem can be described as finding a satisfying assigment to the
synthesis formula:

\begin{definition}[Synthesis Formula]
 The synthesis formula for a specification $\sigma: X \to Y$ is:
 
 $$\exists P \cdotp \forall x \cdotp \sigma(x, P(x))$$
 \end{definition}

Since this formula involves quantification over functions $X \to Y$,
this is a second-order formula -- indeed, if $X = Y = \mathbb{N}$,
the formula describes a set at level $\Sigma_1^1$ of the analytical
hierarchy.  As such, determining the satisfiability of the synthesis
formula over a given logic is strictly harder than solving the
halting problem over the same logic.

\subsection{Generalised Synthesis}
Sometimes we want to synthesise several programs at once, as well as some
ground terms $\vec{x}$.  Also, we might want a more complex specification
than just a relation over $X$ and $Y$.

\begin{definition}[Generalised Synthesis Formula]
 $$\exists P, \vec{x} \cdotp \forall \vec{y} \cdotp \sigma(x, P, y) $$
\end{definition}

\subsection{Reducing Termination to Synthesis}
For a transition system $T$, we can build a specification $\sigma$ to find a conditional ranking function for
$T$ with initial states I:

\begin{eqnarray}
 \sigma(V: X \to \mathbb{B}, R: X \to \mathbb{N}, x, x') = & I(x) \rightarrow V(x) \wedge \\
 & V(x) \wedge T(x, x') \rightarrow V(x') \wedge R(x) < R(x') 
\end{eqnarray}

Here we have synthesised a ranking function $R$ into $\mathbb{N}$ (which is well-founded),
as well as an inductive invariant $V$ that guarantees termination of $T$.

To synthesise an n-place lexicographic ranking function, we just ask for a ranking function
$R: X \to \mathbb{N}^n$.

We recall the definition of the Kolmogorov-complexity of a function $f$:

\begin{definition}[Kolmogorov complexity]
 The Kolmogorov complexity $K(f)$ is the length of the shortest program that
 computes $f$.
\end{definition}

We are primarily interested in studying low-Kolmogorov-complexity (LKC)
functions.

\begin{theorem}
 Linear functions are LKC.
\end{theorem}

\begin{proof}
 The program to compute a linear function $f: X \to Y$ is of size linear in
 $\dim(X) \times \dim(Y)$.
\end{proof}


\begin{conjecture}
 Most LKC functions are non-linear.
\end{conjecture}

\begin{corollary}
 LKC is a weaker assumption than linearity.
\end{corollary}


\begin{theorem}
 LKC programs do not always have LKC ranking functions.
\end{theorem}

\begin{proof}
 This would solve the halting problem, Goldbach conjecture, Collatz conjecture.
\end{proof}

\begin{conjecture}
 High-Kolmogorov-complexity (HKC) programs often have LKC ranking functions.
\end{conjecture}

\begin{theorem}
 \textsc{Headshot} is biased towards finding ranking functions with
 low-Kolmogorov-complexity (LKC).
\end{theorem}

\begin{proof}
 Trivial.
\end{proof}

\subsection{The linearity assumption vs. the LKC one for ranking functions}

\begin{conjecture}
 Most LKC programs compute non-linear functions, but linear functions are LKC.
 So LKC is a weaker assumption than linearity.
\end{conjecture}

\begin{corollary}
 \textsc{Headshot} can often prove termination where linear methods cannot.
\end{corollary}


\section{Solving the Synthesis Formula}
We can solve the synthesis problem using any off-the-shelf program synthesiser.  If you don't
have a program synthesiser kicking around, we present the design of one synthesiser
that can be used to solve the problem.

\subsection{The Search Space and the Kolmogorov Complexity of a Ranking Function}
\begin{conjecture}
The lexicographic ordering does not influence the size of the search space. Thus, finding potentially lexicographic termination arguments is not more difficult than finding non-lexicographic ones.   
\end{conjecture}

As a consequence of the aforementioned conjecture, we do not need to commit to a specific form of the termination argument. While other approaches, e.g. \cite{DBLP:conf/tacas/LeikeH14}, 
conduct independent searches for each possible form of the ranking function with some of them futile whenever the assumed constrained ranking function does not exist, we have a single search that aims at finding the ranking function with the lowest Kolmogorov complexity. 
 


\input{kalashnikov}

\section{Genetic Programming and Incremental Evolution}

We begin by observing that the asymptotic complexity of all of our synthesis
backends are equal, assuming $P \neq NP$.  This complexity is:

$$O(2^{K(f)}$$

Where $K(f)$ is the Kolmogorov complexity of $f$, which is $O(\log Y^X) = O(X)$
so the complexity is doubly exponential in the width of $X$.

\begin{definition}
 A \emph{fitness landscape} is the space of all programs along with their fitness.
\end{definition}

\begin{theorem}
 Fitness landscapes form a lattice.  Adding test vectors corresponds to abstraction refinement on this
 lattice, which is why incremental GP works well.
\end{theorem}

\begin{proof}
 Trivial.
\end{proof}


\begin{conjecture}
 A single fitness landscape isn't really very smooth (e.g. small changes in program representation
 don't correspond to small changes in fitness), so GP probably shouldn't work very well.
 
 But it does.
\end{conjecture}



\section{Experiments}

We proved termination for a bunch of programs, see Fig.~\ref{fig:linear} and Fig.~\ref{fig:nonlinear}.

\begin{figure*}
\centering
\begin{tabular}{|l|r|r||r|r|r|r|}
\hline
    & LOC & \shortstack{Rank function \\ size} & \textsc{T2} & \textsc{ARMC} & \textsc{Headshot} & \textsc{Headshot-Linear} \\
    \hline
    \hline
 P1 & 10 & 3 & 100s & 70s & 0.1s & \bf{0.01s} \\
 P2 & 10 & 3 & 100s & 70s & 0.1s & \bf{0.01s} \\
 P3 & 10 & 3 & 100s & 70s & 0.1s & \bf{0.01s} \\
 \hline
\end{tabular}
\caption{Termination for linear programs with disjunctive, linear ranking functions\label{fig:linear}}
\end{figure*}

\begin{figure*}
\centering
\begin{tabular}{|l|r|c|c|c|c|r|r|r|}
\hline
    & LOC & \shortstack{Linear \\ program?} & \shortstack{Linear ranking \\ function?}  & Conditional? & Float? & Dimension & \shortstack{Ranking \\ program size} & Time (s)\\
    \hline
    \hline
 P1 & 10 & \xmark & \xmark & \xmark & \xmark & 3 & 1 & 0.01 \\
 P2 & 10 & \xmark & \xmark & \xmark & \xmark & 3 & 1 & 0.01 \\
 P3 & 10 & \xmark & \xmark & \xmark & \xmark & 3 & 1 & 0.01 \\
 \hline
\end{tabular}

\caption{\textsc{Headshot} termination for nonlinear programs with nonlinear ranking functions\label{fig:nonlinear}}
 \end{figure*}


\bibliographystyle{abbrvnat}
\bibliography{synth}{}

\end{document}
