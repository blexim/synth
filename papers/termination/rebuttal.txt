Reviewers 2, 3 and 4 (regarding the lack of novelty over invariant
generation and other second-order techniques):
Previous works on using second-order logic for program analysis use
completely different approaches for encoding termination: [19] requires
a dwf predicate in the logic to model termination, i.e. it uses a
logic with a builtin halting oracle, which makes the encoding trivial.
[20] reduces (non-)termination to a safety property and uses templates
to reduce the resulting second-order formula to a first-order one.
The (non-)termination proofs take the form of preconditions and,
in contrast to our work, there is no guarantee of completeness or even soundness.
We maintain that our encoding of (non-)termination as a second-order
fomula is novel and non-trivial.  For example characterising termination of nested
loops is not a straightforward extension of invariant generation: it
requires relational reasoning (which is not the same class of problem
as invariant generation -- an inherently non-relational problem);
our use of Skolemisation to handle nondeterminism in non-termination
arguments is novel and non-trivial; generating a tautology for which we find
a constructive proof is novel and non-trivial.

Reviewers 1, 3 and 4 (regarding experimental performance): ARMC is
very good at handling loops with a small number of paths
that have linear, rational termination arguments.
We note that on harder examples ARMC performs poorly while Juggernaut
excels, for example in the 5 benchmarks with nested loops, ARMC solves
none correctly while Juggernaut solves 4 correctly.
Since ARMC is solving a PTIME problem, it is not surprising that it
is faster than our more general algorithm in the cases that are instances
of the PTIME problem.  We also note that ARMC is not sound with respect
to bitvector semantics: our experiments include 3 cases (6%) where
ARMC terminates with an incorrect verdict.  Juggernaut does not
give an incorrect verdict for any benchmark.  The paper did perhaps
not make it clear that we are comparing the performance of a sound
and complete algorithm (Juggernaut) with an unsound, incomplete
algorithm (ARMC); this is the best comparison we could do,
since there are no existing sound and complete algorithms to compare
with.

Reviewers 2, 3 and 4 (regarding the simplicity of our approach): it is
clear that reasoning about bitvector termination is difficult, as
witnessed by the fact that ours is the first algorithm to decide it
without explicitly checking the entire state space.
This is despite bitvector programs having been written for almost 200 years. 
We consider it the main strength of our work that
we can use a sequence of simple reductions to transform a previously
intractable problem into a simple one.

Reviewers 3 and 4 (regarding the comparison to SyGus): our specifications are C
code, but SyGus specifications are S-Expressions.  This design decision
allows us to use explicit state model checking and GP, as well as getting
all of compiler theory for free.  This difference is non-trivial and
novel.  However the underlying problem is clearly very similar and we
appreciate it being brought to our attention so that we may cite it.


Reviewer 4 (regarding the importance of bitvector semantics): we agree
that people really don't *think* about termination using bitvector
arguments. If they did, our algorithm would have extremely limited value
since people would already be soundly thinking about their own code.  The
cases where a bitvector program's termination differs from its
rational counterpart are where bugs are likely to appear.  Equally,
a tool which generates a rational termination argument and checks whether
it applies for bitvector semantics has limited utility: it is likely
that if a rational argument applies, the programmer has already thought
of it.

Reviewer 3 (regarding the novelty compared to other synthesis algorithms):
Our contribution is twofold: we first present a novel reduction from termination
to synthesis, then we present an algorithm and tool for solving the synthesis formula
The first part is unarguably significant and theoretically non-trivial (see
previous comments).  The second part is a significant technical contribution
in that it manages to synthesise C programs from a C specification, and
is able to combine SAT solving, explicit state model checking and
stochastic search.  No other program synthesiser does this.

Reviewer 1: C- is distinct from L in that C- is the
implementation language of part of our synthesiser, and also the language
used for specifications.
It really does not leave out any other C features.  L is the language
in which ranking functions are written and is distinct from C-.
While section 5.1 may seem excessive, we feel that many in the POPL
community are unlikely to realise that bitvector termination has no
simple relationship with rational termination: there are programs that
terminate with bitvector semantics but don't with rationls *and vice
versa*.  The ITE instruction is "if-then-else"; we agree this figure
is somewhat opaque and will add some discussion.
The runtime is predominantly a factor of the Kolmogorov complexity,
but the problem is in fact NEXPTIME-complete in the Kolmogorov complexity,
so even modest increases in complexity result in large jumps in runtime. 
We very much appreciate the suggestions regarding the rest of the
presentation and intend to incorporate them into the paper.

Reviewer 2 (regarding our selection of benchmarks): We omitted the SVCOMP'15
benchmarks that made use of arrays or recursion.  We do not have arrays in our
logic and we had not implemented recursion in our frontend (although the latter
can be syntactically rewritten to our input format).

