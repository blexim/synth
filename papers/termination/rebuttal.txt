Reviewers 1, 3 and 4 (regarding the experimental performance): ARMC is
very good at handling loops with a small number of paths
that have linear, rational termination arguments.  We note that on
harder examples ARMC performs poorly while Juggernaut excels; for example
in the 5 benchmarks with nested loops, ARMC solves none correctly
while Juggernaut solves 4 correctly and times out on the 5th.
Since ARMC is solving a PTIME problem, it is not surprising that it
is faster than our more general algorithm in the cases that are instances
of the PTIME problem.  We also note that ARMC is not sound with respect
to bitvector semantics: our experiments include 3 cases (6%) where
ARMC terminates with an incorrect verdict.  The paper did perhaps
not make it clear that we are comparing the performance of a sound
and complete algorithm (Juggernaut) with an unsound, incomplete
algorithm (ARMC).

Reviewer 3 (regarding the comparison to SyGus): our specifications are C
code, but SyGus specifications are S-Expressions.  This design decision
allows us to use explicit state model checking and GP, as well as getting
all of compiler theory for free.  This difference is non-trivial and
novel.  However the underlying problem is clearly very similar and we
appreciate it being brought to our attention so that we may cite it.

Reviewers 2, 3 and 4 (regarding the lack of novelty over invariant
generation and other second-order techniques): we contend
that the encoding of (non-)termination as a second-order fomula is
non-trivial.  For example characterising the non-termination of nested
loops is not a straightforward extension of invariant generation: it
requires relational reasoning (which is not the same class of problem
as invariant generation -- an inherently non-relational problem) and
a novel application of Skolemisation to handle nondeterminism.
Furthermore, generating a tautology for which we find a constructive
proof is novel and, we contend, a highly non-trivial insight.
Additionally we note that previous work on using second-order logic
for program analysis does not cover termination: [19] requires
a dwf predicate in the logic to model termination, i.e. it uses a
logic with a builtin halting oracle, which makes the encoding trivial;
[20] mentions termination as an afterthought.

Reviewer 4 (regarding the importance of bitvector semantics): we agree
that people really don't *think* about termination using bitvector
arguments. If they did, our algorithm would have extremely limited value
since people would already be soundly thinking about their own code.  The
cases where a bitvector program's termination differs from its
rational counterpart are where bugs are likely to appear.  Equally,
a tool which generates a rational termination argument and checks whether
it applies for bitvector semantics has limited utility: it is likely
that if a rational argument applies, the programmer has already thought
of it.

Reviewers 2, 3 and 4 (regarding the simplicity of our approach): it is
clear that reasoning about bitvector termination is difficult, as
witnessed by the fact that ours is the first algorithm to decide it
effectively.  We consider it the main strength of our work that
we can use a sequence of simple reductions to transform a previously
intractable problem into a simple one.


Reviewer 1 (miscellaneous): C- is distinct from L in that C- is the
implementation language of part of our synthesiser, and also the language
used for specifications.
It really does not leave out any other C features.  L is the language
in which ranking functions are written and is distinct from C-.
While section 5.1 may seem excessive, we feel that many in the POPL
community are unlikely to realise that bitvector termination has no
simple relationship with rational termination: there are programs that
terminate with bitvector semantics but don't with rationls *and vice
versa*.  The ITE instruction is "if-then-else"; we agree this figure
is somewhat opaque and will add some discussion.
The runtime is predominantly a factor of the Kolmogorov complexity,
but the problem is in fact NEXPTIME-complete in the Kolmogorov complexity,
so even modest increases in complexity result in large jumps in runtime. 
We very much appreciate the suggestions regarding the rest of the
presentation and intend to incorporate them into the paper.

Reviewer 2 (miscellaneous): We do not consider our contribution to be that
we have run a lot of experiments, we consider it to be that we have
presented the first algorithm to decide bitvector termination.
We omitted the SVCOMP'15 benchmarks that made use of arrays or
recursion.  We do not have arrays in our logic and we had not implemented
recursion in our frontend (although the latter is uninteresting
theoretically).

Reviewer 3 (miscellaneous): Our contribution is twofold: we first
present a novel reduction from termination to synthesis, then we present
an algorithm and tool for solving the synthesis formula.  The first part is
unarguably significant and theoretically non-trivial (see previous
comment).  The second part is a significant algorithmic contribution
in that it manages to synthesise C programs from a C specification, and
is able to combine SAT solving, explicit state model checking and
stochastic search.  No other program synthesiser does this.
